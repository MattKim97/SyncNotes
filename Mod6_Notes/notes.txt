Notes for Thursday 7/9/2024

Covering Docker, Containers , Imagers, and MySQL

DOCKER

    a platform for building shipping and running applications in a consistent manner
    provides the dependencies that an application needs
    docker compose up -> automatically updated and downloaded everything in the container
    good thing about docker can immediately remove all things related to the container
    no need to uninstall everything after using the application

CONTAINERS

    standardized containers are used in-order to keep everything in a standardized and isolated environment
    make sure everything works across different computers
    containers keep everything isolated from our own underlying systems

VMs vs Containers

    virtual machines are basically virtualizing an OS basically allowing multiple OS to run on one computer

    -problems with VM
        - each BM needs a full-blown OS
        - very slow to start
        - very very very resource intensive

    - benefits of containers
        - needs less hardware resources
        - allows running of multiple applications in isolation
        - start quickly
        - use the host machines OS - no need to download multiple OS


We basically use docker as a server in this course --- don't go much further than that

Kernel - core of the OS

Everything OS has its own kernels and each oif these kernels have different APIs

This is why we cannot use windows containers oin a MAC container

Docker uses a lightweight VM

A Docker images includes everything for an application to run, files configuration settings ETC.

Once we have an image we can start that container from the image

a container is LIKE a VM because it is an isolated environment that we can execute applications in
- Whatever happens in each container are invisible to other containers

Just using docker for databases and as a server in this course, use docker as a server to run our databases


DEV WORKFLOW

A Docker file is a plain text file that includes instructions for docker to package up the application into an image
these images include everything that we need for our application to run such as
    - OS
    - Run time environment (Node or JDK)
    - any application files
    - third party library's like spring or react
    - environment variables

With docker, we don't have to use or maintain release documents that need to be precisely followed.

Docker files start with FROM, telling us what image the file is from

COPY -> Where we need to go to copy the source code

ENV which would be our environment variables

this is our configurations and it is automatiable

takes a whole team up and running in just a couple of minutes and no intimate knowledge of how our database works

ENVIRONMENTS

    deployment = hosting it on a server so that others can connect to it, it is not useful just local

    dev environment = this is our local machine -- dev -> named branch (named feature)

    testing environment = this is where our app is tested -- testing branch

    staging = setting up our app for production - could exist for only a few seconds -- exists before merging into main ( 2 seconds when you click on merge into main)

    production = launching to our users -- main

All this is possible because of containers, we don't know what is in them, but we just know we can ship them around.

DOCKER COMMANDS
    - docker container prune (delete all containers not running)
    - no way to recover when removing containers
    - only remove if you want to completely remove them



SOME SQL NOTES
 - 1 to 1 table are usually larger tables that are broke apart into smaller tables
 - inner join only show matching rows, combines the matching rows
 - aggregating is the act of taking many values and then reducing them down to a single value
 - count(*) * only allowed for count aggregates
 - any aggregate query can make a where clause, records are filtered before aggregate is applied
 - always be consistent with naming between tables and models
 - Natural Key
    - a natural key naturally occurs in the data
    - is unique

 - Surrogate key
    - not naturally occurring within the data, something that we create


DATABASE DESIGN NOTES
    - will require planning and takes a lot of time
    - well-designed
        - easily extended
        - query easily
    - poorly designed
        - eventually will prevent extension
        - a lot of maintenance
    - Systematic approach
    1. understand the business requirements ( look @ existing forms if we don't know existing DB)
    2. build conceptual model of the business representation of these concepts
    3. build logical model -> all the tables and columns
    4. build physical model -> the implementation of the logical model